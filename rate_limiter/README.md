本项目使用 Go 实现了四种经典限流算法：**固定窗口（Fixed Window）**、**滑动窗口（Sliding Window）**、**漏桶（Leaky Bucket）** 和 **令牌桶（Token Bucket）**，并通过 Gin 和 gRPC 框架分别演示了如何集成这些限流器。

---

## 🧠 项目目标

- 掌握常见限流模型的原理与实现
- 能在实际项目中接入高效限流逻辑，保护系统稳定性
- 提供 Gin HTTP 和 gRPC 两种服务端集成示例

---

## 🔧 限流器说明

### 1. Fixed Window（固定窗口限流器）

**原理**：将时间划分为固定长度的窗口（如每秒），每个窗口只允许指定数量的请求，超过的请求被拒绝。

**优点**：

* 实现简单，性能开销小

**缺点**：

* 存在突刺问题：窗口切换瞬间可能处理大量请求

**适用场景**：中小型系统，突发不敏感的接口限流

---

### 2. Sliding Window（滑动窗口限流器）

**原理**：记录每个请求的时间戳，统计过去固定时间内的请求数量，实现更加平滑的限流。

**优点**：

* 更平滑，无突刺问题

**缺点**：

* 实现较复杂，需记录时间戳，内存开销略大

**适用场景**：API 网关、高并发服务

---

### 3. Leaky Bucket（漏桶限流器）

**原理**：请求以任意速率进入桶中，但处理速率固定；桶满时新请求被拒绝。

**优点**：

* 平滑输出，适合削峰

**缺点**：

* 延迟较高，不支持突发请求

**适用场景**：带宽控制、日志系统、消息发送限速

---

### 4. Token Bucket（令牌桶限流器）

**原理**：系统周期性向桶中放令牌，请求需消耗令牌才能通过，支持一定量的突发请求。

**优点**：

* 兼顾平滑和突发，灵活性强

**缺点**：

* 实现复杂，需要计算令牌生成逻辑

**适用场景**：高并发 API、支付系统、用户行为限速

---



---

如你需要我将这个 README 转换为中文版（用于内部文档或 wiki），或根据实际路径调整，也可以告诉我。是否还需要我生成示例 proto 文件或客户端调用代码？
```
